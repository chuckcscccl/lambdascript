//Parser generated by rustlr for grammar untyped

#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_mut)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(dead_code)]
#![allow(irrefutable_let_patterns)]
extern crate rustlr;
use rustlr::{Tokenizer,TerminalToken,ZCParser,ZCRProduction,Stateaction,decode_action};
use rustlr::{LBox,unbox};
use crate::untyped::*;
use crate::untyped::Term::*;

const SYMBOLS:[&'static str;27] = ["lambda","lam","Lam","(",")","[","]","DOT","let","=","in","define","lazy","weak","CBV","Liang",";","INTEGER","ID","T","F","Fs","Vars","LAMSYM","Ts","START","EOF"];

const TABLE:[u64;221] = [12885229568,90194575361,98785230849,47245099008,34360655872,103079608321,589824,4295819264,81604444161,77309542400,60130066432,85900066817,55835361280,73014640640,8590589952,281543697235968,562967133552642,563022968127490,562992903356418,563018673160194,563027263094786,562962838585346,844442110328834,844493649936386,844497944903682,844502239870978,844467880132610,844437815361538,1125985807302657,1125977216385024,1125942856908802,1125917087105026,1125972921483264,1125912792072192,1125968626712578,1407422128652288,1407452193095680,1407409244209152,1407465078128641,1407473668784129,1407435013619712,1407456489111553,1407383474143232,1407387768782848,1407374884143104,1407379179372544,1407430718914560,1407447898193920,1407460783620097,1688884220919808,1688940054839297,1688931465887745,1688858450853888,1688935760330753,1688948645494785,1688849860853760,1688905695625216,1688961529413635,1688862745493504,1688854156083200,1688909990330368,1688897105362944,1688922874904576,1688927169806336,1970402147762176,1970376377892864,2251877123227648,2251872828325888,2251885714472961,2251812698914816,2533352100855810,2814827077697538,3096237628850178,3096241923817474,3096267693621250,3096293463425026,3096297758392322,3096302053359618,3377785621381121,3377777030070272,3377772735168512,3377712605757440,3659252007763970,3940726984933376,4222201961775104,4222219141578753,4503608217305090,4503599627370498,4503672641814530,4503655461945346,4503633987108866,4503646872010754,4503711296520194,4503612512272386,4503676936781826,4503659756912642,4503603922337794,4785151913689090,4785147618721794,4785087489179650,4785117553950722,4785091784146946,4785143323754498,5066566762430464,5348093278814208,5629576845524992,5911013167595520,6192492437831682,6192518207635458,6192466668027906,6473967414607874,6473941644804098,6473993184411650,6755438097793024,7036904484700160,7036951729274880,7318426704609282,7318379459969026,7599893091123202,7599841551515650,7599867321319426,7599897386090498,7599837256548354,7599901681057794,7881346592604162,7881372362407938,7881303642931202,7881376657375234,7881355182538754,7881411017113602,7881312232865794,7881307937898498,7881333707702274,7881359477506050,7881299347963906,8162812981542912,8444257891909632,8444339495895041,8444335201386497,8444262186549248,8444305136680960,8444283661975552,8444253597138944,8444322315960320,8444309431386112,8444296546418688,8444330907992065,8444348086550529,8444249301909504,8444326610862080,8725797292670976,8725784408096768,8725758638686208,8725810178097153,8725780113391616,8725732868620288,8725814472605697,8725724278620160,8725737163259904,8725771523129344,8725801587572736,8725823063261185,8725805884768257,8725728573849600,9007276564938754,9007229320298498,9288734361518080,9288764426027009,9288687116681216,9288760131518465,9288751540994048,9288755838255105,9288678527270912,9288773016682497,9288682822041600,9288747246092288,9288721476550656,9288708592107520,9288730066812928,9288674232041472,9570157798752256,9570153503981568,9570209338228736,9570205043523584,9570235108229121,9570162093391872,9570222222802944,9570230815031297,9570226517704704,9570183568818176,9570247993393153,9570196453261312,9570149208752128,9570239402737665,9851667135463426,9851692905267202,9851641365659650,10133142113812480,10414642858426370,10414617088622594,10414591318818818,10696117835464706,10696092065660930,10696066295857154,10977605698715649,10977622876946433,10977532682305536,10977528387534848,10977609991782401,10977601401257984,10977536976945152,10977524092305408,10977597106356224,10977614286290945,10977579927076864,10977558452371456,10977571336814592,10977584221782016,11259042018951170,11259067788754946,11259016249147394,];

pub fn make_parser() -> ZCParser<Term,Vec<LBox<Term>>>
{
 let mut parser1:ZCParser<Term,Vec<LBox<Term>>> = ZCParser::new(20,41);
 let mut rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("start");
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("Ts");
 rule.Ruleaction = |parser|{ let mut _item1_ = parser.popstack(); let mut x = parser.popstack();  parser.exstate.push(x.lbox()); Nothing };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("Ts");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut x = parser.popstack(); let mut _item0_ = parser.popstack();  parser.exstate.push(x.lbox()); Nothing };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("Fs");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); 
  if let (a,)=(_item0_.value,) {  a }  else {parser.bad_pattern("(a,)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("Fs");
 rule.Ruleaction = |parser|{ let mut b = parser.popstack(); let mut a = parser.popstack();  App(a.lbox(), b.lbox()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("F");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); 
  if let ((x),)=(_item0_.value,) {  x } /* var */  else {parser.bad_pattern("((x),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("F");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); 
  if let ((x),)=(_item0_.value,) {  x } /* const*/  else {parser.bad_pattern("((x),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("T");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); 
  if let (a,)=(_item0_.value,) {  a }  else {parser.bad_pattern("(a,)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("F");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (a,)=(_item1_.value,) {  a }  else {parser.bad_pattern("(a,)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("T");
 rule.Ruleaction = |parser|{ let mut x = parser.popstack(); let mut _item0_ = parser.popstack();  CBV(x.lbox()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("T");
 rule.Ruleaction = |parser|{ let mut x = parser.popstack(); let mut _item0_ = parser.popstack();  Weak(x.lbox()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("T");
 rule.Ruleaction = |parser|{ let mut b = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Seq(mut vs),)=(_item1_.value,) { 
  let mut t = b.value;
  while vs.len()>0 {
    t = Abs(getvar(&unbox!(vs.pop().unwrap())),parser.lbx(0,t));
  }
  return t; }  else {parser.bad_pattern("(Seq(mut vs),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("Vars");
 rule.Ruleaction = |parser|{ let mut x = parser.popstack();  Seq(vec![x.lbox()]) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("Vars");
 rule.Ruleaction = |parser|{ let mut y = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Seq(mut vs),)=(_item0_.value,) {  vs.push(y.lbox()); Seq(vs) }  else {parser.bad_pattern("(Seq(mut vs),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("T");
 rule.Ruleaction = |parser|{ let mut b = parser.popstack(); let mut _item4_ = parser.popstack(); let mut v = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Var(x),)=(_item1_.value,) {  App(parser.lbx(0,Abs(x,b.lbox())), v.lbox()) }  else {parser.bad_pattern("(Var(x),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("T");
 rule.Ruleaction = |parser|{ let mut v = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Var(x),)=(_item1_.value,) { 
  let nv = Def(true,x,v.lbox());
  //parser.exstate.push(parser.lbx(0,nv));
  nv 
 }  else {parser.bad_pattern("(Var(x),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("T");
 rule.Ruleaction = |parser|{ let mut v = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Var(x),)=(_item2_.value,) { 
  let nv = Def(false,x,v.lbox());
  nv 
 }  else {parser.bad_pattern("(Var(x),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("LAMSYM");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); <Term>::default()};
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("LAMSYM");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); <Term>::default()};
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("LAMSYM");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); <Term>::default()};
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("START");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); <Term>::default()};
 parser1.Rules.push(rule);
 parser1.Errsym = "";
 parser1.resynch.insert(";");

 for i in 0..221 {
   let symi = ((TABLE[i] & 0x0000ffff00000000) >> 32) as usize;
   let sti = ((TABLE[i] & 0xffff000000000000) >> 48) as usize;
   parser1.RSM[sti].insert(SYMBOLS[symi],decode_action(TABLE[i]));
 }

 for s in SYMBOLS { parser1.Symset.insert(s); }

 load_extras(&mut parser1);
 return parser1;
} //make_parser

fn load_extras(parser:&mut ZCParser<Term,Vec<LBox<Term>>>)
{
  parser.RSM[9].insert("Liang",Stateaction::Error("there's no such thing as lambda-liang calculus; although I did invent an extention of lambda calculus, I didn't name it after myself. maybe someday somebody will name it after me."));
  parser.RSM[2].insert("lambda",Stateaction::Error("a lambda-expression in an application term should be placed inside ()'s"));
  parser.RSM[32].insert("ANY_ERROR",Stateaction::Error("invalid expression; sometimes this is caused by forgetting the DOT (.) after lambda"));
  parser.RSM[32].insert("Liang",Stateaction::Error("MAKING FUN OF PROFESSOR LIANG IS FORBIDDEN! REPENT!"));
  parser.RSM[1].insert(")",Stateaction::Error("this ) does not have a matching ("));
  parser.RSM[27].insert("Liang",Stateaction::Error("MAKING FUN OF PROFESSOR LIANG WILL BRING YOU BAD LUCK AND REALLY BAD GRADES"));
  parser.RSM[21].insert("ANY_ERROR",Stateaction::Error("a '=' is required in a definition"));
  parser.RSM[2].insert("DOT",Stateaction::Error("if I had to guess, you misspelled lambda; you can use lambda, lam or Lam"));
  parser.RSM[2].insert("ANY_ERROR",Stateaction::Error("maybe you forgot a ; at the end of the previous line"));
  parser.RSM[2].insert("EOF",Stateaction::Error("maybe you forgot a ; at the end of a line"));
  parser.RSM[7].insert("Liang",Stateaction::Error("all my life people have been trying to define me, but nobody can define me. I'm undefinable."));
  parser.RSM[33].insert("Liang",Stateaction::Error("MAKING FUN OF PROFESSOR LIANG IS NOT A GOOD IDEA, CONSIDERING HE CAN WRITE A PROGRAM LIKE THIS AND YOU HAVE NO IDEA HOW!"));
  parser.RSM[2].insert("Liang",Stateaction::Error("ARE YOU TRYING TO MAKE FUN OF PROFESSOR LIANG? WHAT A DWEEB!"));
  parser.RSM[0].insert("Liang",Stateaction::Error("MAKING FUN OF PROFESSOR LIANG IS NOT A GOOD IDEA, CONSIDERING THAT HE CAN WRITE A PROGRAM LIKE THIS AND YOU HAVE NO CLUE HOW!"));
}//end of load_extras: don't change this line as it affects augmentation
