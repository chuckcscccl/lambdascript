//Parser generated by rustlr for grammar untyped

#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_mut)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(dead_code)]
#![allow(irrefutable_let_patterns)]
extern crate rustlr;
use rustlr::{Tokenizer,TerminalToken,ZCParser,ZCRProduction,Stateaction,decode_action};
use rustlr::{LBox,unbox};
use crate::untyped::*;
use crate::untyped::Term::*;

const SYMBOLS:[&'static str;27] = ["lambda","lam","Lam","(",")","[","]","DOT","let","=","in","define","lazy","weak","CBV","Liang",";","INTEGER","ID","T","F","Fs","Vars","LAMSYM","Ts","START","EOF"];

const TABLE:[u64;221] = [77309870080,90195099649,60130459648,4295819264,98784772097,8590131200,103079477249,81604509697,12885622784,47244705792,55835557888,73015099392,85899739137,327680,34360328192,281526517366784,281552287236096,563018674077696,844502240722946,1125904202661888,1126011575992323,1125960037302272,1125985806581761,1125981512466433,1125998691614721,1125899907170304,1125972921942016,1125947151548416,1125934267170816,1125912792465408,1125977216712704,1125990101942273,1125955742400512,1125908496973824,1407452194013186,1688922874839042,1688862745296898,1688867040264194,1688918579871746,1688892810067970,1688927169806338,1970402146648066,1970397851680770,1970393556713474,1970367786909698,1970337722138626,1970342017105922,2251877124472832,2251894304276481,2533352101249024,2814766947303426,2814762652336130,2814818486910978,2814822781878274,2814792717107202,2814827076845570,3096306349703169,3096229039636480,3096314938916865,3096302053687296,3096224744144896,3096280579375104,3096284874276864,3096259104145408,3096323528589313,3096297758916608,3096271988523008,3096233333948416,3096310643556353,3096237629440000,3377772735627264,3377716900790274,3377768440397826,3377785621446657,3377712606150656,3377777030397952,3377742670594050,3659252007763970,3940726983819264,3940722689048576,3940735574933505,3940662559571968,4222197665759232,4222210551709697,4222137536282624,4222201960529920,4503676938551296,4785113260621824,5066583940530178,5066661249941506,5066553875759106,5066549580791810,5066609710333954,5066562465693698,5066596825432066,5066622595235842,5066605415366658,5066626890203138,5066558170726402,5348093278879744,5629576845656064,5629529600950272,5911004576415746,5911051821056002,6192488144437248,6473941646376960,6755476750663682,6755468160729090,6755416621121538,6755412326154242,6755442390925314,6755472455696386,7036943137767426,7036891598159874,7036917367963650,7318392344739842,7318366574936066,7318418114543618,7599863028121600,7881389542998017,7881376657768448,7881312233521152,7881355183456256,7881380954570753,7881359478358016,7881303643717632,7881299348226048,7881346592604160,7881385247637505,7881398132670465,7881333708226560,7881307938029568,7881372362997760,8162834454216706,8162821569314818,8162885993824258,8162851634085890,8162774324674562,8162808684412930,8162778619641858,8162782914609154,8162830159249410,8162787209576450,8162847339118594,8444309431779328,8444249301647360,8444330908057601,8444322316419072,8444326611189760,8444257891450880,8444283661647872,8444262186942464,8444339496419329,8444253597138944,8444296546025472,8444335201058817,8444305136877568,8444348086091777,8725801588228098,8725754343587842,9007207844872192,9007289449840641,9007280861544449,9007285154480129,9007259385200640,9007276564611072,9007246499446784,9007199255068672,9007203550560256,9007212140363776,9007272269840384,9007233615069184,9007298039513089,9007255090298880,9288742951387138,9288717181583362,9288751541321730,9288691411779586,9288747246354434,9288687116812290,9570226518032384,9570153503981568,9570235107901441,9570196452868096,9570183568490496,9570149208489984,9570162093785088,9570247992934401,9570205043720192,9570230815031297,9570209338621952,9570239403261953,9570157798293504,9570222223261696,9851667135463426,9851692905267202,9851641365659650,10133167881715714,10133142111911938,10133116342108162,10414617090523136,10696092065660930,10696066295857154,10696117835464706,10977584222175232,10977605698715649,10977571336421376,10977609991454721,10977579927273472,10977614286815233,10977524092043264,10977532681846784,10977536977338368,10977558452043776,10977601401585664,10977528387534848,10977622876487681,10977597106814976,11259067788754946,11259016249147394,11259042018951170,];

pub fn make_parser() -> ZCParser<Term,Vec<LBox<Term>>>
{
 let mut parser1:ZCParser<Term,Vec<LBox<Term>>> = ZCParser::new(20,41);
 let mut rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("start");
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("Ts");
 rule.Ruleaction = |parser|{ let mut _item1_ = parser.popstack(); let mut x = parser.popstack();  parser.exstate.push(x.lbox()); Nothing };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("Ts");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut x = parser.popstack(); let mut _item0_ = parser.popstack();  parser.exstate.push(x.lbox()); Nothing };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("Fs");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); 
  if let (a,)=(_item0_.value,) {  a }  else {parser.bad_pattern("(a,)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("Fs");
 rule.Ruleaction = |parser|{ let mut b = parser.popstack(); let mut a = parser.popstack();  App(a.lbox(), b.lbox()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("F");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); 
  if let ((x),)=(_item0_.value,) {  x } /* var */  else {parser.bad_pattern("((x),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("F");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); 
  if let ((x),)=(_item0_.value,) {  x } /* const*/  else {parser.bad_pattern("((x),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("T");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); 
  if let (a,)=(_item0_.value,) {  a }  else {parser.bad_pattern("(a,)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("F");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (a,)=(_item1_.value,) {  a }  else {parser.bad_pattern("(a,)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("T");
 rule.Ruleaction = |parser|{ let mut x = parser.popstack(); let mut _item0_ = parser.popstack();  CBV(x.lbox()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("T");
 rule.Ruleaction = |parser|{ let mut x = parser.popstack(); let mut _item0_ = parser.popstack();  Weak(x.lbox()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("T");
 rule.Ruleaction = |parser|{ let mut b = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Seq(mut vs),)=(_item1_.value,) { 
  let mut t = b.value;
  while vs.len()>0 {
    t = Abs(getvar(&unbox!(vs.pop().unwrap())),parser.lbx(0,t));
  }
  return t; }  else {parser.bad_pattern("(Seq(mut vs),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("Vars");
 rule.Ruleaction = |parser|{ let mut x = parser.popstack();  Seq(vec![x.lbox()]) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("Vars");
 rule.Ruleaction = |parser|{ let mut y = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Seq(mut vs),)=(_item0_.value,) {  vs.push(y.lbox()); Seq(vs) }  else {parser.bad_pattern("(Seq(mut vs),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("T");
 rule.Ruleaction = |parser|{ let mut b = parser.popstack(); let mut _item4_ = parser.popstack(); let mut v = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Var(x),)=(_item1_.value,) {  App(parser.lbx(0,Abs(x,b.lbox())), v.lbox()) }  else {parser.bad_pattern("(Var(x),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("T");
 rule.Ruleaction = |parser|{ let mut v = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Var(x),)=(_item1_.value,) { 
  let nv = Def(true,x,v.lbox());
  //parser.exstate.push(parser.lbx(0,nv));
  nv 
 }  else {parser.bad_pattern("(Var(x),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("T");
 rule.Ruleaction = |parser|{ let mut v = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Var(x),)=(_item2_.value,) { 
  let nv = Def(false,x,v.lbox());
  nv 
 }  else {parser.bad_pattern("(Var(x),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("LAMSYM");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); <Term>::default()};
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("LAMSYM");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); <Term>::default()};
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("LAMSYM");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); <Term>::default()};
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("START");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); <Term>::default()};
 parser1.Rules.push(rule);
 parser1.Errsym = "";
 parser1.resynch.insert(";");

 for i in 0..221 {
   let symi = ((TABLE[i] & 0x0000ffff00000000) >> 32) as usize;
   let sti = ((TABLE[i] & 0xffff000000000000) >> 48) as usize;
   parser1.RSM[sti].insert(SYMBOLS[symi],decode_action(TABLE[i]));
 }

 for s in SYMBOLS { parser1.Symset.insert(s); }

 load_extras(&mut parser1);
 return parser1;
} //make_parser

fn load_extras(parser:&mut ZCParser<Term,Vec<LBox<Term>>>)
{
}//end of load_extras: don't change this line as it affects augmentation
